package com.sia.scheduler.log.worker.service;import com.sia.core.constant.Constant;import com.sia.core.entity.JobMTask;import com.sia.scheduler.log.worker.LogMessage;import com.sia.scheduler.log.enums.LogStatusEnum;import org.slf4j.Logger;import org.slf4j.LoggerFactory;import java.util.concurrent.*;public class LogProduceService {    private static final Logger LOGGER = LoggerFactory.getLogger(LogProduceService.class);    private static final int poolSize = 1;    private static final int workCount = 1000;    //这里需要使用公平模式，否则可能导致task日志在job日志之前落库    private static ExecutorService executor =            new ThreadPoolExecutor(poolSize, poolSize, 0L, TimeUnit.SECONDS,                    new LinkedBlockingQueue<>(workCount), new RejectedExecutionHandler() {                @Override                public void rejectedExecution(Runnable r, ThreadPoolExecutor executor) {                    LOGGER.error(Constant.LOG_PREFIX + "BlockingQueue is full, executing reject policy! Log content: {} from {}",                            r.toString(), executor.toString());                }            });    public static void produceLogs(JobMTask mTask, String message, LogStatusEnum status) {        produce(mTask, message, status);    }    private static void produce(JobMTask mTask, String message, LogStatusEnum status){        executor.submit(new LogMessage(mTask, message, status));    }}