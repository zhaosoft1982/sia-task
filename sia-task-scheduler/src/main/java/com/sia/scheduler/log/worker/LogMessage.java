package com.sia.scheduler.log.worker;import com.sia.core.entity.JobMTask;import com.sia.scheduler.log.enums.LogStatusEnum;import com.sia.scheduler.log.worker.service.LogConsumeService;import lombok.AllArgsConstructor;import lombok.Data;@Data@AllArgsConstructorpublic class LogMessage implements Runnable {    private JobMTask mTask;    private String message;    private LogStatusEnum status;    @Override    public void run() {        switch (status) {            case LOG_JOB_HANDLE_BEGIN:                jobStartScheduling();                break;            case LOG_TASK_END_FINISHED:            case LOG_TASK_FINISHED:            case LOG_TASK_CALLBACKERROR:            case LOG_TASK_HANDLE_BEGIN:            case LOG_TASK_FAIL_STOP:            case LOG_TASK_FAIL_IGNORE:            case LOG_TASK_FAIL_MULTI_CALLS:            case LOG_TASK_FAIL_MULTI_CALLS_TRANSFER:            case LOG_TASK_FAIL_DETAIL:            case LOG_TASK_FAIL_TRANSFER:                recordTaskLog();                break;            case LOG_JOB_ENDTASK_FINISHED:            case LOG_JOB_HANDLE_FAIL_STOP:            case LOG_JOB_FAIL_MULTI_CALLS:            case LOG_JOB_FAIL_MULTI_CALLS_TRANSFER:            case LOG_JOB_FAIL_TRANSFER:            case LOG_JOB_FAIL_IGNORE:                recordJobFinishedLogs();                break;            default:                break;        }    }    private void jobStartScheduling(){        LogConsumeService.jobStartScheduling(mTask);    }    private void recordTaskLog(){        LogConsumeService.recordTaskLog(mTask, status, message);    }    private void recordJobFinishedLogs(){        LogConsumeService.recordJobFinishedLogs(mTask, status);    }}